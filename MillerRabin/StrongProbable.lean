import Mathlib

import MillerRabin.FermatProbable
import MillerRabin.Lemmas
import MillerRabin.Val2

/-!
# Strong Probable Primes

References:
- [conrad2011miller]. We largely follow Section 5 of this paper, but we have some modifications.
-/

open Nat

/--
Let `n : ℕ` and let `n - 1 = 2 ^ s' * d` where `d` is odd.
`n` is a *strong probable prime* to base `a`, if `a ^ d = 1` or `∃ s < s', a ^ (2 ^ s * d) = -1`.
We also say `a` is a *nonwitness* to the primality of `n`.

This is Def. 2.3 of [conrad2011miller].
-/
def SPP (n : ℕ) (a : ZMod n) : Prop :=
  a ^ oddPart (n - 1) = 1 ∨
  ∃ s < val₂ (n - 1), a ^ (2 ^ s * oddPart (n - 1)) = -1

section Algorithm

/-! ### Decidability of strong probable primality -/

/-!
Informally, let the *Miller–Rabin sequence* for `n` generated by `a` be:
$$ (a^d, a^{2d}, a^{4d}, \dots, a^{2^{s-1}d}, \ldots) $$
modulo `n` where `n - 1 = 2 ^ s * d` and `d` is odd. Then `n` is SPP to base `a` if and only if
the sequence starts with `1` or contains a `-1`.

This can be easily decided by an algorithm that computes the following (pseudo)code:
```lean
do
  let mut b := a ^ d
  if b = 1 then return true
  for _ in List.range s do
    if b = -1 then return true
    b := b * b
  return false
```
-/

/-- The inner loop of the single-pass Miller–Rabin algorithm. -/
def millerRabinAux {n : ℕ} (s : ℕ) (b : ZMod n) : Bool := Id.run do
  let mut b := b
  for _ in List.range s do
    if b == -1 then return true
    b := b * b
  return false

lemma _root_.List.range_succ_eq_cons_map_succ (s : ℕ) :
    List.range (s + 1) = 0 :: (List.range s).map Nat.succ := by
  induction s with
  | zero => simp
  | succ s ih =>
    conv_lhs => rw [List.range_succ]
    conv_rhs => rw [List.range_succ]
    simp [ih]

lemma millerRabinAux_eq_true_iff {n : ℕ} (s : ℕ) (b : ZMod n) :
    millerRabinAux s b = true ↔ ∃ s' : ℕ, s' < s ∧ b ^ 2 ^ s' = -1 := by
  unfold millerRabinAux
  induction s generalizing b with
  | zero => simp
  | succ s ih =>
    rw [List.range_succ_eq_cons_map_succ]
    by_cases h : b = -1
    · simpa [h] using ⟨0, succ_pos _, by norm_num⟩
    · suffices (∃ s' < s, (b * b) ^ 2 ^ s' = -1) ↔ ∃ s' < s + 1, b ^ 2 ^ s' = -1 by
        simpa [h] using (ih (b * b)).trans this
      constructor
      · intro ⟨s', hs', hs''⟩
        use s' + 1, by omega, by simpa [pow_succ', pow_mul, pow_two] using hs''
      · intro ⟨s', hs', hs''⟩
        have : s' ≠ 0 := by rintro rfl; apply h; simpa using hs''
        rw [show s' = s' - 1 + 1 by omega] at hs''
        use s' - 1, by omega, by simpa [pow_succ', pow_mul, pow_two] using hs''

/-- The single-pass *Miller–Rabin algorithm* that decides `SPP` in $O(\log^3 n)$. -/
def millerRabin {n : ℕ} (a : ZMod n) : Bool := Id.run do
  let s := val₂ (n - 1)
  let k := (n - 1) / 2 ^ s
  let b := a ^ k
  return b == 1 || millerRabinAux s b

/-- `millerRabin` decides `SPP`. -/
lemma millerRabin_eq_true_iff {n : ℕ} (a : ZMod n) :
    millerRabin a = true ↔ SPP n a := by
  simp [millerRabin, millerRabinAux_eq_true_iff, SPP, pow_mul, pow_right_comm]

end Algorithm

namespace SPP

section Decidable

/-- The algorithm `millerRabin` that decides `SPP` in $O(\log^3 n)$ as an instance. -/
instance decidable {n : ℕ} {a : ZMod n} :
    Decidable (SPP n a) :=
  propext (millerRabin_eq_true_iff a) ▸ decEq _ _

-- Test on large prime
example : @SPP 944955065201210920149993400889 2 := by native_decide
-- Test on large composite number
example : ¬@SPP 844955065201210920149993400889 2 := by native_decide

end Decidable

section FPP

/-- `n` is SPP to base `a` if `n` is FPP to base `a` and the square roots of 1 are ±1. -/
theorem of_fpp_of_mul_self_eq_one {n : ℕ} {a : ZMod n}
    (hf : FPP n a) (h : ∀ x : ZMod n, x * x = 1 → x = 1 ∨ x = -1) :
    SPP n a := by
  rw [SPP]
  rw [FPP, ← two_pow_val₂_mul_oddPart (n - 1)] at hf
  generalize oddPart (n - 1) = d, val₂ (n - 1) = s at *
  induction s with
  | zero =>
    left; rwa [Nat.pow_zero, one_mul] at hf
  | succ s ih =>
    rw [Nat.pow_succ, mul_right_comm, pow_mul, pow_two] at hf
    rcases h _ hf with h | h
    · rcases ih h with _ | ⟨s', hs', hs''⟩
      · left; assumption
      · right; exact ⟨s', hs'.trans (lt_succ_self s), hs''⟩
    · right; exact ⟨s, lt_succ_self s, h⟩

/-- A prime is a strong probable prime to any nonzero base. -/
theorem of_prime {p : ℕ} [Fact p.Prime] {a : ZMod p} (ha : a ≠ 0) :
    SPP p a :=
  of_fpp_of_mul_self_eq_one (FPP.of_prime ha) (fun _ ↦ mul_self_eq_one_iff.mp)

/-- Strong probable primes are Fermat probable primes. -/
theorem fpp {n : ℕ} {a : ZMod n} (h : SPP n a) :
    FPP n a := by
  rw [FPP, ← two_pow_val₂_mul_oddPart (n - 1)]
  rcases h with h | ⟨s, hs, h⟩
  · rw [mul_comm, pow_mul, h, one_pow]
  · rw [← Nat.sub_add_cancel hs.le, pow_add, mul_rotate, pow_mul, h,
      ← succ_pred (sub_ne_zero_of_lt hs), Nat.pow_succ, mul_comm, pow_mul, neg_one_sq, one_pow]

theorem orderOf_dvd_sub_one {n : ℕ} {a : ZMod n} (h : SPP n a) :
    orderOf a ∣ n - 1 :=
  h.fpp.orderOf_dvd_sub_one

theorem isUnit {n : ℕ} (hn : 2 ≤ n) {a : ZMod n} (h : SPP n a) :
    IsUnit a :=
  h.fpp.isUnit hn

end FPP

section NonwitnessGroup

open Subgroup

/-- The subgroup of `(ZMod n)ˣ` generated by all bases `a` such that `SPP n a`. -/
def nonwitnessGroup (n : ℕ) : Subgroup (ZMod n)ˣ :=
  closure { a | SPP n a }

variable {n : ℕ}

theorem mem_nonwitnessGroup {a : (ZMod n)ˣ} (h : SPP n a) :
    a ∈ nonwitnessGroup n :=
  subset_closure h

lemma nonwitnessGroup_le (K : Subgroup (ZMod n)ˣ) (h : ∀ a : (ZMod n)ˣ, SPP n a → a ∈ K) :
    nonwitnessGroup n ≤ K :=
  (closure_le K).mpr h

lemma spp_unit_iff {a : (ZMod n)ˣ} :
    SPP n a ↔ a ^ oddPart (n - 1) = 1 ∨
      ∃ s : ℕ, s < val₂ (n - 1) ∧ a ^ (2 ^ s * oddPart (n - 1)) = -1 := by
  simp [SPP, Units.ext_iff]

section OfPrimePow

theorem of_prime_pow_of_pow_sub {p m : ℕ} {a : ZMod (p ^ m)} [pp : Fact p.Prime]
    (hm : m > 0) (hp : p > 2) (ha : a ^ (p ^ m - 1) = 1) :
    SPP (p ^ m) a := by
  have : Fact (p ^ m > 1) := ⟨Nat.one_lt_pow hm.ne' pp.out.one_lt⟩
  apply of_fpp_of_mul_self_eq_one ha
  intro x
  rcases lt_or_ge x.val (1 : ZMod (p ^ m)).val with hx₁ | hx₁
  · rw [ZMod.val_one, lt_one_iff, ZMod.val_eq_zero] at hx₁
    rw [hx₁, zero_mul]
    exact fun h ↦ .inl h
  rcases le_or_gt (p ^ m) (x.val + (1 : ZMod (p ^ m)).val) with hx₂ | hx₂
  · have := le_antisymm hx₂ (by rw [ZMod.val_one]; exact (ZMod.val_lt _))
    rw [ZMod.val_add_val_of_le this.le, right_eq_add, ZMod.val_eq_zero,
      add_eq_zero_iff_eq_neg] at this
    exact fun _ ↦ .inr this
  suffices x * x - 1 = 0 → x - 1 = 0 ∨ x + 1 = 0 by
    rwa [sub_eq_zero, sub_eq_zero, add_eq_zero_iff_eq_neg] at this
  rw [← ZMod.natCast_zmod_val (x * x - 1), ← ZMod.natCast_zmod_val (x - 1),
    ← ZMod.natCast_zmod_val (x + 1), ZMod.natCast_eq_zero_iff,
    ZMod.natCast_eq_zero_iff, ZMod.natCast_eq_zero_iff, mul_self_sub_one,
    ZMod.val_mul, dvd_mod_iff (dvd_refl _), ZMod.val_add_of_lt hx₂, ZMod.val_sub hx₁,
    ZMod.val_one]
  generalize x.val = y
  intro h
  by_cases h' : p ∣ y - 1
  · replace h' : ¬p ∣ y + 1 := by
      intro h''
      have := p.dvd_sub h'' h'
      rw [add_comm, Nat.add_sub_assoc (y.sub_le 1), Nat.sub_sub_eq_min] at this
      apply hp.not_ge
      exact (le_of_dvd (by omega) this).trans (by omega)
    left; exact Prime.pow_dvd_of_dvd_mul_left pp.out.prime m h' h
  · right; exact Prime.pow_dvd_of_dvd_mul_right pp.out.prime m h' h

/-!
We show that the group `nonwitnessGroup (p ^ m)` is just `(powMonoidHom (p - 1)).ker`,
and has cardinality `p - 1`, for odd primes `p`.
-/

variable {m p : ℕ} [pp : Fact p.Prime]

theorem nonwitnessGroup_of_prime_pow (hm : 0 < m) (hp : 2 < p) :
    nonwitnessGroup (p ^ m) = (powMonoidHom (p - 1)).ker := by
  have ⟨k, hk⟩ : p - 1 ∣ p ^ m - 1 := by
    convert nat_sub_dvd_pow_sub_pow p 1 m
    exact m.one_pow.symm
  apply le_antisymm
  · apply nonwitnessGroup_le
    intro a ha
    have : Nat.gcd (φ (p ^ m)) (p ^ m - 1) = p - 1 := by
      rw [totient_prime_pow pp.out hm, Nat.gcd_comm, Coprime.gcd_mul _ <| .pow_left _ <|
        (coprime_self_sub_right (one_le_two.trans pp.out.two_le)).mpr <| coprime_one_right _,
        Coprime.gcd_eq_one <| .pow_right _ <| (coprime_pow_right_iff hm _ _).mp <|
        (coprime_self_sub_left (one_le_pow _ _ pp.out.pos)).mpr <| coprime_one_left _, one_mul,
        gcd_eq_right ⟨k, hk⟩]
    rw [MonoidHom.mem_ker, powMonoidHom_apply, ← orderOf_dvd_iff_pow_eq_one, ← this]
    apply Nat.dvd_gcd (orderOf_dvd_of_pow_eq_one (ZMod.pow_totient a))
    rw [← orderOf_units]
    exact orderOf_dvd_sub_one ha
  · intro a ha
    rw [MonoidHom.mem_ker, powMonoidHom_apply, Units.ext_iff] at ha
    push_cast at ha
    exact mem_nonwitnessGroup (of_prime_pow_of_pow_sub hm hp (by rw [hk, pow_mul, ha, one_pow]))

/-
Below is really just an application of Hensel's lemma, but we don't have a form of Hensel in
mathlib that can be easily converted to this. Instead we use an elementary proof as in [Conrad].
-/

private noncomputable def rem (y : ZMod (p ^ (m + 1))) :
    { r : ZMod (p ^ (m + 1)) //
      y = ((y.cast : ZMod (p ^ m)).cast : ZMod (p ^ (m + 1))) + (p : ZMod (p ^ (m + 1))) ^ m * r } := by
  have := ZMod.natCast_val (R := ZMod (p ^ m)) y
  choose r hr using (ZMod.natCast_eq_iff _ _ _).mp this
  apply_fun Nat.cast (R := ZMod (p ^ (m + 1))) at hr
  rw [ZMod.natCast_zmod_val, cast_add, ← ZMod.cast_eq_val, cast_mul, cast_pow] at hr
  exact ⟨(r : ZMod (p ^ (m + 1))), hr⟩

private lemma cast_cast_pow {x : (ZMod (p ^ m))} :
    ((x.cast : ZMod (p ^ (m + 1))).cast : ZMod (p ^ m)) = x :=
  ZMod.cast_cast_zmod_of_le (Nat.pow_lt_pow_right pp.out.one_lt m.lt_succ_self).le _

private lemma lift_unique (hm : 0 < m) (x : (ZMod (p ^ m))ˣ) (hx : x ^ (p - 1) = 1) (y : (ZMod (p ^ (m + 1)))) :
    (y.cast : ZMod (p ^ m)) = x ∧ y ^ (p - 1) = 1 ↔
      y = (x.val.cast : ZMod (p ^ (m + 1))) - p ^ m * rem ((x.val.cast : ZMod (p ^ (m + 1))) ^ (p - 1)) *
        ((x.val.cast : ZMod (p ^ (m + 1))) ^ (p - 2))⁻¹ * (p - 1 : ZMod (p ^ (m + 1)))⁻¹ := by
  have : Fact (1 < p ^ m) := ⟨one_lt_pow hm.ne' pp.out.one_lt⟩
  have := (rem ((x.val.cast : ZMod (p ^ (m + 1))) ^ (p - 1))).2
  nth_rw 1 [← ZMod.castHom_apply (h := pow_dvd_pow p m.lt_succ_self.le)] at this
  rw [RingHom.map_pow, ZMod.castHom_apply, cast_cast_pow, ← sub_eq_iff_eq_add'] at this
  rw [Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one] at hx
  rw [← this, hx, ZMod.cast_eq_val 1, ZMod.val_one, cast_one]
  have cancel :
      ((x.val.cast : ZMod (p ^ (m + 1))) ^ (p - 2)) * (p - 1) * ((x.val.cast : ZMod (p ^ (m + 1))) ^ (p - 2))⁻¹ *
        ((p : ZMod (p ^ (m + 1))) - 1)⁻¹ = 1 := by
    rw [mul_right_comm (_ ^ _), ZMod.mul_inv_of_unit, one_mul, ZMod.mul_inv_of_unit]
    · have : (p - 1).Coprime (p ^ (m + 1)) := by
        apply Coprime.pow_right
        rw [coprime_self_sub_left pp.out.pos]
        exact coprime_one_left p
      simpa only [ZMod.coe_unitOfCoprime, cast_sub pp.out.pos, cast_one] using
        (ZMod.unitOfCoprime _ this).isUnit
    · by_cases hp : p = 2
      · simp only [hp, Nat.sub_self, _root_.pow_zero, isUnit_one]
      rw [isUnit_pow_iff (Nat.sub_ne_zero_of_lt (lt_of_le_of_ne pp.out.two_le (Ne.symm hp)))]
      have : x.val.val.Coprime (p ^ (m + 1)) := by
        apply Coprime.pow_right
        rw [← coprime_pow_right_iff hm]
        exact ZMod.val_coe_unit_coprime x
      simpa only [ZMod.coe_unitOfCoprime, ZMod.natCast_val] using
        (ZMod.unitOfCoprime _ this).isUnit
  have hrem := (rem (y : ZMod (p ^ (m + 1)))).2
  constructor
  · intro ⟨h₁, h₂⟩
    nth_rw 1 [h₁] at hrem
    rw [hrem, mul_comm, ZMod.add_mul_prime_pow_pow _ _ hm (zero_lt_sub_of_lt pp.out.one_lt), Nat.sub_sub,
      cast_sub pp.out.pos, cast_one, ← eq_sub_iff_add_eq'] at h₂
    rw [hrem, sub_eq_add_neg, add_left_cancel_iff, ← neg_mul, ← neg_mul, neg_sub, ← h₂,
      ← one_mul (_ * _)]
    nth_rw 1 [← cancel]
    ring
  · intro h
    have h₁ := congrArg (ZMod.castHom (pow_dvd_pow p m.lt_succ_self.le) (ZMod (p ^ m))) h
    rw [ZMod.castHom_apply, map_sub, map_mul, map_mul, map_sub, ZMod.castHom_apply, map_pow,
      ZMod.castHom_apply, map_one, ZMod.castHom_apply, cast_cast_pow, hx, sub_self, zero_mul,
      zero_mul, sub_zero] at h₁
    use h₁
    nth_rw 1 [h₁] at hrem
    rw [hrem, sub_eq_add_neg, add_left_cancel_iff, ← neg_mul, ← neg_mul, neg_sub] at h
    rw [hrem, mul_comm, ZMod.add_mul_prime_pow_pow _ _ hm (zero_lt_sub_of_lt pp.out.one_lt), Nat.sub_sub,
      cast_sub pp.out.pos, cast_one, mul_assoc (_ ^ _), mul_comm _ (_ ^ _), h,
      ← eq_sub_iff_add_eq', ← one_mul (1 - _)]
    nth_rw 5 [← cancel]
    ring

private lemma card_ker_powMonoidHom_sub_one_of_prime_pow (hm : 0 < m) :
    Nat.card ((powMonoidHom (p - 1)).ker : Subgroup (ZMod (p ^ m))ˣ) = p - 1 := by
  induction m, hm using Nat.le_induction with
  | base =>
    calc
      _ = Nat.card (ZMod (p ^ 1))ˣ := by
        rw [card_eq_iff_eq_top, eq_top_iff', pow_one]
        intro x
        rw [MonoidHom.mem_ker, powMonoidHom_apply, ZMod.units_pow_card_sub_one_eq_one]
      _ = p - 1 := by
        rw [Nat.card_eq_fintype_card, ZMod.card_units_eq_totient, pow_one, totient_prime pp.out]
  | succ m hm ih =>
    conv_rhs => rw [← ih]
    simp_rw [MonoidHom.mem_ker, powMonoidHom_apply]
    refine Nat.card_congr ⟨?_, ?_, ?_, ?_⟩
    · intro ⟨x, hx⟩
      use ZMod.unitsMap (pow_dvd_pow p m.lt_succ_self.le) x
      rw [← MonoidHom.map_pow, hx, MonoidHom.map_one]
    · intro ⟨x, hx⟩
      letI y := (x.val.cast : ZMod (p ^ (m + 1))) - p ^ m * rem ((x.val.cast : ZMod (p ^ (m + 1))) ^ (p - 1)) *
        ((x.val.cast : ZMod (p ^ (m + 1))) ^ (p - 2))⁻¹ * (p - 1 : ZMod (p ^ (m + 1)))⁻¹
      use Units.ofPowEqOne y (p - 1) ((lift_unique hm x hx y).mpr rfl).2 (sub_ne_zero_of_lt pp.out.one_lt)
      exact Units.pow_ofPowEqOne _ _
    · intro ⟨y, hy⟩
      rw [Subtype.mk.injEq, Units.ext_iff]
      set x := ZMod.unitsMap (pow_dvd_pow p m.lt_succ_self.le) y
      refine ((lift_unique hm x ?_ _).mp ⟨rfl, ?_⟩).symm
      · apply_fun ZMod.unitsMap (pow_dvd_pow p m.lt_succ_self.le) at hy
        rwa [map_pow, map_one] at hy
      · rwa [Units.ext_iff, Units.val_pow_eq_pow_val, Units.val_one] at hy
    · intro ⟨x, hx⟩
      rw [Subtype.mk.injEq, Units.ext_iff, ZMod.unitsMap_def, Units.coe_map, Units.val_ofPowEqOne,
        MonoidHom.coe_coe, ZMod.castHom_apply]
      exact ((lift_unique hm x hx _).mpr rfl).1

theorem card_nonwitnessGroup_of_prime_pow (hm : 0 < m) (hp : p > 2) :
    Nat.card (nonwitnessGroup (p ^ m)) = p - 1 := by
  rw [← card_ker_powMonoidHom_sub_one_of_prime_pow hm, nonwitnessGroup_of_prime_pow hm hp]

end OfPrimePow

section DefS₀G

/-- This is `i₀` in Sec. 5 of [conrad2011miller]. -/
def s₀ (n : ℕ) : ℕ :=
  Nat.findGreatest (fun s ↦ ∃ a : (ZMod n)ˣ, a ^ (2 ^ s * oddPart (n - 1)) = -1) (val₂ (n - 1) - 1)

lemma s₀_lt_val₂ (hn : 2 ≤ n) (ho : Odd n) : s₀ n < val₂ (n - 1) := by
  have hn1 : NeZero (n - 1) := ⟨by omega⟩
  exact lt_of_le_pred (val₂_of_even (Nat.Odd.sub_odd ho ⟨0, rfl⟩)) (findGreatest_le (val₂ (n - 1) - 1))

lemma s₀_spec (hn : 2 ≤ n) : ∃ a : (ZMod n)ˣ, a ^ (2 ^ s₀ n * oddPart (n - 1)) = -1 :=
  findGreatest_spec (P := fun s ↦ ∃ a, a ^ (2 ^ s * oddPart (n - 1)) = -1) (Nat.zero_le _) <| by
    use -1
    have : NeZero (n - 1) := ⟨by omega⟩
    rw [Nat.pow_zero, one_mul, odd_oddPart.neg_one_pow]

lemma two_pow_s₀_lt (hn : 2 ≤ n) (ho : Odd n) : 2 ^ s₀ n * oddPart (n - 1) < n - 1 := by
  have : NeZero (n - 1) := ⟨by omega⟩
  conv_rhs => rw [← two_pow_val₂_mul_oddPart (n - 1)]
  gcongr
  · exact oddPart_pos
  · decide
  · exact s₀_lt_val₂ hn ho

lemma le_s₀ {s : ℕ} {a : (ZMod n)ˣ} (hs : s < val₂ (n - 1))
    (ha : a ^ (2 ^ s * oddPart (n - 1)) = -1) : s ≤ s₀ n :=
  le_findGreatest (le_pred_of_lt hs) ⟨a, ha⟩

def G (n : ℕ) : Subgroup (ZMod n)ˣ :=
  comap (powMonoidHom (2 ^ s₀ n * oddPart (n - 1))) (closure {-1})

theorem nonwitnessGroup_le_G :
    nonwitnessGroup n ≤ G n := by
  apply nonwitnessGroup_le
  intro a ha
  rw [G, mem_comap, powMonoidHom_apply]
  rcases spp_unit_iff.mp ha with ha | ⟨s, hs, ha⟩
  · rw [mul_comm, pow_mul, ha, one_pow]
    exact one_mem (Subgroup.closure {-1})
  · rw [← Nat.add_sub_cancel' (le_s₀ hs ha), pow_add, mul_right_comm, pow_mul, ha,
      mem_closure_singleton]
    use 2 ^ (s₀ n - s)
    norm_cast

end DefS₀G

section OfNotCarmichael

/-- An equivalent of nonwitnessGroup but for Fermat probable primes. -/
def F (n : ℕ) : Subgroup (ZMod n)ˣ :=
  (powMonoidHom (n - 1)).ker

theorem G_lt_F_of_not_isPrimePow (hn : 2 ≤ n) (ho : Odd n) (hnp : ¬IsPrimePow n) :
    G n < F n := by
  apply lt_of_le_of_ne
  · intro a
    rw [G, mem_comap, powMonoidHom_apply, F, MonoidHom.mem_ker, powMonoidHom_apply,
      mem_closure_neg_one]
    intro ha
    rw [← two_pow_val₂_mul_oddPart (n - 1), ← Nat.sub_add_cancel (s₀_lt_val₂ hn ho), pow_add,
      mul_assoc, mul_comm, pow_mul, Nat.pow_succ, mul_right_comm, pow_mul]
    rcases ha with ha | ha <;> rw [ha]
    · rw [one_pow, one_pow]
    · rw [neg_one_sq, one_pow]
  · let ⟨p, s, k, _, _, hpsk, cop, hk, hps⟩ :=
      exists_pow_prime_dvd_and_coprime_of_odd hn ho hnp
    let ⟨a₀, ha₀⟩ := s₀_spec hn
    let a := (ZMod.chineseRemainderₓ cop).symm (ZMod.unitsMap ⟨k, hpsk⟩ a₀, 1)
    let a' := ZMod.unitsMap (dvd_of_eq hpsk) a
    have aF : a' ∈ F n := by
      suffices a ^ (n - 1) = 1 by
        rw [F, MonoidHom.mem_ker, powMonoidHom_apply, ← map_pow, this, map_one]
      suffices a₀ ^ (n - 1) = 1 by
        rw [← map_pow, Prod.pow_mk, one_pow, ← map_pow, this, map_one, ← Prod.one_eq_mk, map_one]
      rw [← two_pow_val₂_mul_oddPart (n - 1), ← Nat.sub_add_cancel (s₀_lt_val₂ hn ho), pow_add,
        mul_assoc, mul_comm, pow_mul, Nat.pow_succ, mul_right_comm, pow_mul, ha₀, neg_one_sq,
        one_pow]
    intro hGF
    rw [← hGF, G, mem_comap, powMonoidHom_apply, mem_closure_neg_one] at aF
    rcases aF with h | h <;>
      apply_fun ZMod.unitsMap (dvd_of_eq hpsk.symm) at h <;>
      rw [map_pow, ← MonoidHom.comp_apply, ZMod.unitsMap_comp, ZMod.unitsMap_self,
        MonoidHom.id_apply] at h
    · have : Fact (p ^ s > 2) := ⟨hps⟩
      apply_fun ZMod.unitsMap ⟨k, rfl⟩ at h
      apply_fun ZMod.unitsMap ⟨k, hpsk⟩ at ha₀
      rw [map_pow, unitsMap_neg_one] at ha₀
      rw [map_one, map_one, map_pow, ZMod.unitsMap_chineseRemainderₓ_symm, ha₀] at h
      exact ZMod.neg_one_ne_one (Units.ext_iff.mp h)
    · have : Fact (k > 2) := ⟨hk⟩
      apply_fun ZMod.unitsMap ⟨p ^ s, mul_comm _ _⟩ at h
      rw [unitsMap_neg_one, unitsMap_neg_one, map_pow, ZMod.unitsMap_chineseRemainderₓ_symm',
        one_pow] at h
      exact ZMod.neg_one_ne_one (Units.ext_iff.mp h.symm)

theorem F_lt_top_of_not_carmichael (hc : ¬FPP.Carmichael n): F n < ⊤ := by
  rw [lt_top_iff_ne_top]
  intro ht
  apply hc
  rw [Subgroup.eq_top_iff'] at ht
  intro a
  have := ht a
  rwa [F, MonoidHom.mem_ker, powMonoidHom_apply, ← FPP.fpp_unit_iff] at this

end OfNotCarmichael

section OfCarmichael

/-! We adapt the proof from [conrad], to a more inductive argument rather than to work with lists of
primes. `H m` is here a subgroup of `(ZMod n)ˣ`, similar to H in [conrad] but `m`-indexed. -/

def H {m n : ℕ} (h : m ∣ n) : Subgroup (ZMod n)ˣ :=
  comap (powMonoidHom (2 ^ s₀ n * oddPart (n - 1))) (comap (ZMod.unitsMap h) (closure {-1}))

/-! We show, for n = m₁m₂m₃ where m₁, m₂, m₃ pairwise coprime (in particular when n Carmichael):
  H(m₁m₂) ⊓ H(m₃) < H(m₁) ⊓ H(m₂) ⊓ H(m₃)
using CRT⁻¹ (a₀ : ℤ/m₁, 1 : ℤ/m₂m₃) in H(m₁) and H(m₂m₃) ≤ H(m₁) ⊓ H(m₂), but not in H(m₁m₂)

Then for pairwise coprime m₁, m₂, m₃:
    G(m₁m₂m₃) = H(m₁m₂m₃) < H(m₁m₂) ⊓ H(m₃) < H(m₁) ⊓ H(m₂) ⊓ H(m₃)
since
· lemma on m₁ := m₁m₂, m₂ := m₃, m₃ := 1 (note H(1) = ⊤)
· lemma on m₁ := m₁, m₂ := m₂, m₃ := m₃
So |G| ≤ 1/4 * φ(n).

With this lemma, I think this generalizes beyond 3 without much difficulty:
  |G| ≤ 2ʳ⁻¹ φ(n) where r = n.primeFactors.length
but is not needed for the 1/4 bound so not proven. -/

theorem G_eq_H :
    G n = H (dvd_refl n) := by
  unfold H G
  rw [ZMod.unitsMap_self, comap_id]

lemma H_one :
    H (one_dvd n) = ⊤ := by
  unfold H
  apply eq_top_iff.mpr
  intro _ _
  rw [mem_comap, mem_comap, mem_closure_neg_one]
  exact .inl (Subsingleton.eq_one _)

lemma H_le_H_of_dvd {m₁ m₂ : ℕ} (h₁ : m₁ ∣ m₂) (h₂ : m₂ ∣ n) :
    H h₂ ≤ H (h₁.trans h₂) := by
  unfold H
  rw [← ZMod.unitsMap_comp h₁ h₂, ← comap_comap]
  apply comap_mono
  apply comap_mono
  intro a ha
  rw [mem_comap]
  rw [mem_closure_neg_one] at ha ⊢
  apply ha.imp <;> rintro rfl
  · exact map_one _
  · exact unitsMap_neg_one _

lemma H_mul_le_H_inf_H {m₁ m₂ : ℕ} (h : m₁ * m₂ ∣ n) :
    H h ≤ H (dvd_of_mul_right_dvd h) ⊓ H (dvd_of_mul_left_dvd h) :=
  le_inf (H_le_H_of_dvd (dvd_mul_right m₁ m₂) h) (H_le_H_of_dvd (dvd_mul_left m₂ m₁) h)

/-- The lemma mentioned above.
Only used for h := dvd_of_eq _, but this very convenient for type casting. -/
theorem H_inf_H_lt_H_inf_H_inf_H [NeZero n] {m₁ m₂ m₃ : ℕ}
    (h₁ : m₁ > 2) (h₂ : m₂ > 2) (hc : m₁.Coprime (m₂ * m₃)) (h₁₂₃n : m₁ * m₂ * m₃ ∣ n) :
    H (dvd_of_mul_right_dvd h₁₂₃n) ⊓ H (dvd_of_mul_left_dvd h₁₂₃n) <
      H (dvd_of_mul_right_dvd (dvd_of_mul_right_dvd h₁₂₃n)) ⊓
      H (dvd_of_mul_left_dvd (dvd_of_mul_right_dvd h₁₂₃n)) ⊓ H (dvd_of_mul_left_dvd h₁₂₃n) := by
  have h₁₂n := dvd_of_mul_right_dvd h₁₂₃n
  have h₁n := dvd_of_mul_right_dvd h₁₂n
  have h₂n := dvd_of_mul_left_dvd h₁₂n
  have h₃n := dvd_of_mul_left_dvd h₁₂₃n
  have h₁₂₃'n := mul_assoc m₁ m₂ m₃ ▸ h₁₂₃n
  have h₂₃n := dvd_of_mul_left_dvd h₁₂₃'n
  have hn : 2 ≤ n := h₁.le.trans (le_of_dvd (pos_iff_ne_zero.mpr NeZero.out) h₁n)
  apply lt_of_le_of_ne (inf_le_inf_right _ (H_mul_le_H_inf_H h₁₂n))
  intro hH
  let ⟨a₀, ha₀⟩ := s₀_spec hn
  let a := (ZMod.chineseRemainderₓ hc).symm (ZMod.unitsMap h₁n a₀, 1)
  let ⟨b, hb⟩ := ZMod.unitsMap_surjective h₁₂₃'n a
  have : b ∈ H h₁₂n := by
    suffices b ∈ H h₁n ⊓ H h₂n ⊓ H h₃n by rw [← hH] at this; exact (mem_inf.mp this).1
    rw [inf_assoc, mem_inf]
    apply And.imp_right fun h ↦ H_mul_le_H_inf_H h₂₃n h
    constructor <;> rw [H, mem_comap, mem_comap, powMonoidHom_apply, mem_closure_neg_one]
    · right
      rw [← ZMod.unitsMap_comp (dvd_mul_right m₁ (m₂ * m₃)) h₁₂₃'n, map_pow, MonoidHom.comp_apply,
        hb, ZMod.unitsMap_chineseRemainderₓ_symm, ← map_pow, ha₀, unitsMap_neg_one]
    · left
      rw [← ZMod.unitsMap_comp (dvd_mul_left (m₂ * m₃) m₁) h₁₂₃'n, map_pow, MonoidHom.comp_apply,
        hb, ZMod.unitsMap_chineseRemainderₓ_symm', one_pow]
  rw [H, mem_comap, mem_comap, powMonoidHom_apply,
    ← ZMod.unitsMap_comp (mul_assoc m₁ m₂ m₃ ▸ dvd_mul_right (m₁ * m₂) m₃) h₁₂₃'n,
    MonoidHom.comp_apply, map_pow, hb, ← map_pow, Prod.pow_mk, one_pow, ← map_pow, ha₀,
    unitsMap_neg_one, mem_closure_neg_one] at this
  rcases this with h | h
  · apply_fun ZMod.unitsMap (dvd_mul_right m₁ m₂) at h
    rw [← MonoidHom.comp_apply, ZMod.unitsMap_comp, ZMod.unitsMap_chineseRemainderₓ_symm, map_one] at h
    have : Fact (m₁ > 2) := ⟨h₁⟩
    exact ZMod.neg_one_ne_one (Units.ext_iff.mp h)
  · apply_fun ZMod.unitsMap (dvd_mul_left m₂ m₁) at h
    rw [← MonoidHom.comp_apply, ZMod.unitsMap_comp,
      ← ZMod.unitsMap_comp (dvd_mul_right m₂ m₃) (dvd_mul_left (m₂ * m₃) m₁), MonoidHom.comp_apply,
      ZMod.unitsMap_chineseRemainderₓ_symm', map_one, unitsMap_neg_one] at h
    have : Fact (m₂ > 2) := ⟨h₂⟩
    exact ZMod.neg_one_ne_one (Units.ext_iff.mp h.symm)

theorem H_lt_H_inf_H {m₁ m₂ : ℕ} [NeZero n] (h₁ : m₁ > 2) (h₂ : m₂ > 2)
    (hc : m₁.Coprime m₂) (h : m₁ * m₂ ∣ n) :
    H h < H (dvd_of_mul_right_dvd h) ⊓ H (dvd_of_mul_left_dvd h) := by
  rw [← inf_top_eq (a := H h), ← inf_top_eq (a := H _ ⊓ H _), ← H_one]
  apply H_inf_H_lt_H_inf_H_inf_H h₁ h₂ <;> rwa [mul_one]

-- Carmichael numbers are of the form of the lemma
theorem eq_mul_mul_of_carmichael (hn : 2 ≤ n) (hc : FPP.Carmichael n) (hnp : ¬n.Prime) :
    ∃ m₁ m₂ m₃, n = m₁ * m₂ * m₃ ∧ m₁.Coprime m₂ ∧ m₁.Coprime m₃ ∧ m₂.Coprime m₃ ∧
      m₁ > 2 ∧ m₂ > 2 ∧ m₃ > 2 := by
    have h := hc.card_primeFactors hn hnp
    have hnpp := hc.not_isPrimePow hn hnp
    have : NeZero n := ⟨by omega⟩
    have hsf := hc.squarefree
    rcases hn.eq_or_lt with rfl | hn2
    · simp [Nat.prime_two] at hnp
    have ho := hc.odd hn2
    obtain ⟨p, s, k, pp, spos, rfl, pcop, hk, hps⟩ :=
      exists_pow_prime_dvd_and_coprime_of_odd hn ho hnpp
    obtain rfl : s = 1 := by
      by_contra hs
      apply pow_two p ▸ squarefree_iff_prime_squarefree.mp hsf p pp
      use p ^ (s - 2) * k
      rw [← mul_assoc, ← pow_add,
        Nat.add_sub_cancel' (lt_of_le_of_ne spos.nat_succ_le (Ne.symm hs))]
    rw [p.pow_one] at *
    have : Fact (k ≥ 2) := ⟨hk.le⟩
    have hok : Odd k := ho.of_dvd_nat ⟨p, mul_comm _ _⟩
    obtain ⟨q, t, l, _, _, rfl, qcop, hl, hqt⟩ :=
      exists_pow_prime_dvd_and_coprime_of_odd hk.le hok <| by
        rintro ⟨q, t, pq, _, rfl⟩
        rw [primeFactors_mul (by positivity) (by positivity), pp.primeFactors,
          primeFactors_prime_pow (by positivity) pq.nat_prime, Finset.card_union,
          Finset.card_singleton, Finset.card_singleton] at h
        omega
    use p, q ^ t, l, (mul_assoc _ _ _).symm
    use pcop.coprime_mul_right_right, pcop.coprime_mul_left_right

end OfCarmichael

theorem nonwitnessGroup_lt_lt_of_not_isPrimePow (hn : 2 ≤ n) (ho : Odd n) (hnpp : ¬IsPrimePow n) :
    ∃ K : Subgroup (ZMod n)ˣ, nonwitnessGroup n < K ∧ K < ⊤ := by
  have hnp : ¬n.Prime := fun np ↦ hnpp np.isPrimePow
  have : NeZero n := ⟨by omega⟩
  by_cases hc : FPP.Carmichael n
  · rcases eq_mul_mul_of_carmichael hn hc hnp with ⟨m₁, m₂, m₃, hn, h₁₂, h₁₃, h₂₃, h₁, h₂, h₃⟩
    use H ((dvd_mul_right (m₁ * m₂) m₃).trans (dvd_of_eq hn.symm)) ⊓
      H ((dvd_mul_left m₃ (m₁ * m₂)).trans (dvd_of_eq hn.symm))
    constructor
    · calc
      nonwitnessGroup n ≤ G n := nonwitnessGroup_le_G
      G n = H (dvd_refl n) := G_eq_H
      H _ = H (dvd_of_eq hn.symm) := le_antisymm (H_le_H_of_dvd (dvd_of_eq hn.symm) (dvd_refl n))
        (H_le_H_of_dvd (dvd_of_eq hn) (dvd_of_eq hn.symm))
      _ < _ := H_lt_H_inf_H ((by norm_num : 2 < 4).trans_le (Nat.mul_le_mul h₁.le h₂.le)) h₃
        (h₁₃.mul_left h₂₃) (dvd_of_eq hn.symm)
    · calc
      _ < H _ ⊓ H _ ⊓ H _ := H_inf_H_lt_H_inf_H_inf_H h₁ h₂ (h₁₂.mul_right h₁₃) (dvd_of_eq hn.symm)
      _ ≤ ⊤ := le_top
  · use F n
    constructor
    · calc
      nonwitnessGroup n ≤ G n := nonwitnessGroup_le_G
      G n < F n := G_lt_F_of_not_isPrimePow hn ho hnpp
    · exact F_lt_top_of_not_carmichael hc

theorem card_nonwitnessGroup_of_not_prime (hn : 2 ≤ n)
    (ho : Odd n) (hnp : ¬n.Prime) (h9 : n ≠ 9) :
    4 * Nat.card (nonwitnessGroup n) ≤ φ n := by
  by_cases hpp : IsPrimePow n
  · have ⟨p, m, pp, hm, h⟩ := hpp
    obtain rfl := h
    replace pp := pp.nat_prime
    have : Fact p.Prime := ⟨pp⟩
    have hp : p > 2 := lt_of_le_of_ne pp.two_le fun hp ↦ ho.not_two_dvd_nat ⟨p ^ m.pred,
      by rw [← hp, mul_comm, ← Nat.pow_succ, m.succ_pred hm.ne']⟩
    calc
    _ = 4 * (p - 1) := by rw [card_nonwitnessGroup_of_prime_pow hm hp]
    _ ≤ φ (p ^ m) := by
      rw [totient_prime_pow pp hm]
      apply Nat.mul_le_mul_right
      replace hm := lt_of_le_of_ne hm.nat_succ_le fun pm ↦ hnp (by rwa [← pm, pow_one])
      rcases hm.nat_succ_le.eq_or_lt with rfl | hm
      · rw [pow_one]; by_contra hp
        interval_cases p
        exact h9 rfl
      apply (pow_le_pow_left' pp.two_le 2).trans
      exact pow_le_pow_right' pp.pos (le_pred_of_lt hm)
  · have ⟨K, hK₁, hK₂⟩ := nonwitnessGroup_lt_lt_of_not_isPrimePow hn ho hpp
    classical
    have : NeZero n := ⟨by omega⟩
    calc
      _ = 2 * (2 * Nat.card (nonwitnessGroup n)) := by rw [← mul_assoc]; rfl
      _ ≤ 2 * Nat.card K := Nat.mul_le_mul_left 2 (card_mul_two_le_of_lt hK₁)
      _ ≤ Nat.card (⊤ : Subgroup _) := card_mul_two_le_of_lt hK₂
      _ = Fintype.card (ZMod n)ˣ := card_top.trans Nat.card_eq_fintype_card
      _ = φ n := ZMod.card_units_eq_totient n

end NonwitnessGroup

/-- The proportion of Miller–Rabin nonwitnesses of composite `n` is at most 1/4. -/
theorem card_of_not_prime {n : ℕ} (hn : 2 ≤ n) (ho : Odd n) (hnp : ¬n.Prime) :
    4 * Nat.card {a // SPP n a} ≤ n - 1 := by
  by_cases h9 : n = 9
  · obtain rfl := h9
    have val28 : val₂ 8 = 3 := padicValNat.prime_pow 3
    have (a : ZMod 9) : SPP 9 a ↔ a = 1 ∨ a = -1 := by
      rw [SPP, oddPart, val28]
      constructor
      · contrapose!
        intro ⟨h1, hn1⟩
        fin_cases a <;> first | contradiction | decide
      · rintro (rfl | rfl) <;> decide
    simp_rw [Nat.card_eq_fintype_card, Fintype.card_subtype, this]
    decide
  · calc
      4 * Nat.card {a // SPP n a} ≤ 4 * Nat.card (nonwitnessGroup n) := by
        gcongr
        have (x : {a // SPP n a}) : ∃ a' : nonwitnessGroup n, a'.val.val = x.val := by
          choose a' ha' using x.prop.isUnit hn
          use ⟨a', mem_nonwitnessGroup (ha' ▸ x.prop)⟩
        choose f hf using this
        apply Nat.card_le_card_of_injective f
        intro ⟨a₁, ha₁⟩ ⟨a₂, ha₂⟩ h
        apply_fun ((↑) : _ → (ZMod n)ˣ) at h
        apply_fun ((↑) : _ → ZMod n) at h
        simpa [hf] using h
      _ ≤ φ n := card_nonwitnessGroup_of_not_prime hn ho hnp h9
      _ ≤ n - 1 := le_pred_of_lt (totient_lt n hn)

end SPP
